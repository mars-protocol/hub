package keeper

import (
	"encoding/json"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"

	wasmkeeper "github.com/CosmWasm/wasmd/x/wasm/keeper"
	wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"

	"github.com/mars-protocol/hub/custom/gov/types"
)

// defaultContractAddr is the wasm contract address generated by code ID 1 and instance ID 1.
//
// In other words, the first ever contract to be deployed on this chain will necessarily have this address.
var defaultContractAddr = wasmkeeper.BuildContractAddress(1, 1)

// queryVotingPowers queries the vesting contract of user voting powers based on the given query msg
func queryVotingPowers(ctx sdk.Context, k wasmtypes.ViewKeeper, contractAddr sdk.AccAddress, query *types.VotingPowersQuery) (types.VotingPowersResponse, error) {
	var votingPowersResponse types.VotingPowersResponse

	req, err := json.Marshal(&types.QueryMsg{VotingPowers: query})
	if err != nil {
		return nil, sdkerrors.Wrapf(types.ErrFailedToQueryVesting, "failed to marshal query request: %s", err)
	}

	res, err := k.QuerySmart(ctx, contractAddr, req)
	if err != nil {
		return nil, sdkerrors.Wrapf(types.ErrFailedToQueryVesting, "query returned error: %s", err)
	}

	err = json.Unmarshal(res, &votingPowersResponse)
	if err != nil {
		return nil, sdkerrors.Wrapf(types.ErrFailedToQueryVesting, "failed to unmarshal query response: %s", err)
	}

	return votingPowersResponse, nil
}

// incrementVotingPowers increments the voting power counter based on the contract query response
func incrementVotingPowers(votingPowersResponse types.VotingPowersResponse, tokensInVesting map[string]sdk.Uint, totalTokensInVesting *sdk.Uint) error {
	for _, item := range votingPowersResponse {
		if _, ok := tokensInVesting[item.User]; ok {
			return sdkerrors.Wrapf(types.ErrFailedToQueryVesting, "query response contains duplicate address: %s", item.User)
		}

		tokensInVesting[item.User] = item.VotingPower
		*totalTokensInVesting = totalTokensInVesting.Add(item.VotingPower)
	}

	return nil
}

// GetTokensInVesting queries the vesting contract for an array of users who have tokens locked in the
// contract and their respective amount, as well as computing the total amount of locked tokens.
func GetTokensInVesting(ctx sdk.Context, k wasmtypes.ViewKeeper, contractAddr sdk.AccAddress) (map[string]sdk.Uint, sdk.Uint, error) {
	tokensInVesting := make(map[string]sdk.Uint)
	totalTokensInVesting := sdk.ZeroUint()

	votingPowersResponse, err := queryVotingPowers(ctx, k, contractAddr, &types.VotingPowersQuery{})
	if err != nil {
		return nil, sdk.ZeroUint(), err
	}

	if err = incrementVotingPowers(votingPowersResponse, tokensInVesting, &totalTokensInVesting); err != nil {
		return nil, sdk.ZeroUint(), err
	}

	for {
		count := len(votingPowersResponse)
		if count == 0 {
			break
		}

		startAfter := votingPowersResponse[count-1].User

		votingPowersResponse, err = queryVotingPowers(ctx, k, contractAddr, &types.VotingPowersQuery{StartAfter: startAfter})
		if err != nil {
			return nil, sdk.ZeroUint(), err
		}

		if err = incrementVotingPowers(votingPowersResponse, tokensInVesting, &totalTokensInVesting); err != nil {
			return nil, sdk.ZeroUint(), err
		}
	}

	return tokensInVesting, totalTokensInVesting, nil
}
